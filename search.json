[{"title":"犀牛书","url":"/2019/10/24/犀牛书/","content":"# JavaScript概述\n高端的/动态的/弱类型语言\n\n谷歌引擎即javascript解释器为V8\n\n通过方括号定义数组元素和通过花括号定义对象属性名和属性值之间的映射关系的语法称为初始化表达式（initializer\nexpression）\n\njavascript定义了特殊的序列使用6个ASCII字符来表示任意16位Unicode内码，以\\u为前缀后跟四个十六进制数\n\nJavaScript中当不再有任何引用指向一个对象，解释器就会自动回收该对象所占用的内存\n\nJavaScript采用词法作用域，不在任何函数内声明的变量称为全局变量，函数内的变量具有函数作用域\n\nJavaScript所有数字均用浮点数值表示，用64位浮点数值表示，但计算时采用32位计算\n\n一个数字直接出现在JavaScript程序中称为数字直接量，但负号是一元求反运算符，并不是数字直接量语法的组成部分\n\nMath.pow(2,53)  2的53次幂\nMath.ceil(.6)   向上求整   1.0\nMath.sqrt(3)    3的平方根\nMath.exp(3)     e的三次幂\n\nJavaScript运算符溢出，当数字超过所表示的数字上限，结果为一个特殊无穷大，用Infinity表示\n\n下溢是当运算结果无限趋于零并比能表示的最小值还小的时候，此时JavaScript返回0，当一个负数发生下溢时，JavaScript返回一个“负零”\n\n非数字同任何值都是不相等的包括自身，同样不能通过X==NaN来判断变量X是NaN\n\n使用 X！= X 当且仅当X = NaN，表达式的值才为true\n\ncharAt(x)返回第x+1个字符\n\nsubstring(1,4)返回第2~4个字符\n\nslice(1,4)同上\n\nslice(-3)最后三个字符\n\nsplit(\",\")分割成字串\n\nreplace(\"h\",\"H\")用字母H代替字母h\n\ntoUpperCase()全部转换为大写\n\nreplace与toUpperCase的方法都返回新字符串而不改变原字符串\n\nnull是JavaScript的关键字 undefined不是关键字，它的值就是“未定义”\n\nundefined是表示系统级的、出乎意料的或类似错误的值的空缺\n\nnull是表示程序级的、正常的或在意料之中的值的空缺\n\n如果你想将它们赋值给变量或者属性，或将它们作为参数传入函数，最佳选择是使用null\n\n只要引用了字符串的属性，JavaScript就会通过调用new String()的方式转换成对象，这个对象继承了字符串的方法，并被用来处理属性的引用，一旦属性引用结束后，这个新创建的对象就会被销毁\n\n存取字符串、数字或布尔值的属性时创立的临时对象称做包装对象，它只是偶尔区分字符串和字符串、数字和数值对象以及布尔值和布尔对象\n\n包装对象只是被看作是一种实现细节，而不用特别关注，字符串、数字和布尔值额属性都是只读的，并不能给他们定义新属性\n\n原始值的比较是值的比较，对象的比较并非值的比较：即使两个对象包含相同的属性及相同的值，它们也是不相等的。各个索引元算完全相等的两个数组也不相等\n\n对象称为引用类型，对象的值都是引用，对象的比较均是引用的比较：当且仅当它们引用同一个基对象时，它们才相等\n\n原始值到对象的转换通过调用String()、Number()或Boolean()构造函数生成包装对象\n\n如果将null和undefined期望转换为一个对象，会造成类型错误(throws TypeError)\n\n一个值转换为另一个值并不意味两值相等\n\n显式类型转换\n使用Boolean()、Number()、String()或Object()不使用new会作为类型转换函数\n\nnull和undefined没有toString()方法，同时转换它们成对象会抛出类型错误\n\nparseInt()和parseFloat()都会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容，第一个是非法的数字直接量则返回NaN\n\n对象转换为原始值\n1.对象转到布尔：所有对象都转为true，包装对象也是如此\n2.对象转到字符串是通过调用转换方法来实现的\ntoString()和valueOf()\n\nJavascript中对象到字符串的转换经过了如下这些步骤：\n先用toString()方法，如果没有使用valueOf()方法，如果都没有办法从中获得一个原始值，则它会抛出一个类型错误异常\n\n数字过程相反，先使用valueOf()后使用toString(),后抛出异常\n\n全局变量是全局对象的属性\n\n# 对象\n对象是属性的无序集合，每个属性都是一个名/值对\n\n变量x指向一个对象的引用，如果执行let y=x； 那么变量y也指向同一个对象的引用，通过变量y修改这个对象亦会对x造成影响\n\n属性特性：\n可写：表明可设置该属性的值\n可枚举：是否可以for/in循环\n可配置：是否可删除或修改该属性\n\n对象的三个对象特性：\n1.对象的原型(prototype)指向另外一个对象，本对象的属性继承来自它的原型对象\n2.对象的类(class)是一个标识对象类型的字符串\n3.对象的扩展标记(extensible flag)指明了(在ES5)中是否可以向该对象添加新属性\n\n\n三类对象：\n1.内置对象：数组、函数、日期和正则表达式\n2.宿主对象：表示网页结构的HTMLElemnet对象均是宿主对象\n3.自定义对象\n两类属性：\n1.自有属性：直接在对象中的定义的属性\n2.继承属性：对象的原型对象中定义的属性\n\n对象直接量是一个表达式，这个表达式每次运算都创建并初始化一个新对象\n\n## 原型\n每一个JavaScript对象(null除外)都和另一个对象关联，“另一个”对象就是原型，每一个对象都从原型继承属性\n\n对象直接量创建的对象都具有同一个原型对象，并且可以通过Object.prototype获得原型对象的引用\n\n通过new和构造函数创建的对象的原型就是构造函数的prototype属性的值\n\n同使用{}创建对象一样，通过Object()创建的对象也继承自Object.prototype\n\n### Object.prototype是没有原型的对象，不继承任何属性\n\n所有的内置构造函数以及大部分自定义构造函数都具有一个继承自Object.prototype的原型\n\n属性的查询和设置可以使用\".\"或方括号[]\n\n关联数组采用字符串索引而不是数字索引，也称做散列、映射或字典\n\n使用[]数组写法和字符串表达式来访问对象属性很灵活，可以动态改变访问的值\n\n字符串是动态的可以在程序运行时更改的，而标识符是静态的，必须写死在程序中\n\n只有查询属性时才会体会到继承的存在，而设置属性和继承无关\n\n属性值要么失败要么创建一个属性，要么在原始对象中设置属性\n\n查询一个不存在的属性不会报错，会返回Undefined，如果对象不存在，那么试图查询这个不存在的对象就会报错，null和undefined值都没有属性，查询这些值的属性会报错\n\nlet len = book&&book.subtitle&&book.subtitle.length\n通过使用&&运算符短路功能\n\n##### 在这些场景下给对象o设置属性p会失败：\n不能给只读属性重新赋值（defineProperty()方法中有一个例外，可以对可配置的只读属性重新赋值）\n\n不能通过同名自有属性覆盖只读的继承属性\n\n没有使用setter方法继承属性p，并且o的可扩展性（extensible attribute）是false\n\ndelete只是断开属性和宿主对象的联系，而不会去操作属性中的属性\n只能删除自有属性，不能删除继承属性，如果想删除继承属性要删除该属性的原型对象，并且会影响到所有继承自这个原型的对象\n\n通过变量声明和函数声明创建的全局对象的属性不能删除\n\n##### 属性检测\n判断某个属性是否存在于某个对象中，可通过in运算符、hasOwnPreperty()和propertyIsEnumerable()方法来工作\n\n对象的hasOwnProperty()方法用来检测给定的名字是否是对象的自有属性，对于继承属性它将返回false\n\npropertyIsEnumerable()是hasOwnProperty()的增强版，只有检测到是\n自有属性且这个属性的可枚举性（enumerable attribute）为true时它才返回true\n\n使用！==判断一个属性是否是undefined\no.x!==undefined;//true:o中有属性x\no.y!==undefined;//false:o中没有属性y\no.toString!==undefined;//true:o继承了toString属性\n\nObject.keys()，它返回一个数组，这个数组由对象中可枚举的自有属性的名称组成\n\n#### 属性getter和setter\n对象属性是由名字、值和一组特性构成，属性值可以用一个或两个方法替代，这两个方法是setter和getter\n\n由getter和setter定义的属性称做“存取器属性”，不同于“数据属性”，数据属性只有一个值\n\n调用getter方法是程序查询存储器属性值时，这个方法的返回值就是属性存取表达式的值\n\n设置一个存取器属性的值时调用setter方法，将赋值表达式右侧的值当做参数传入setter\n\nlet o={//普通的数据属性\ndata_prop:value,//存取器属性都是成对定义的函数\nget accessor_prop(){/*这里是函数体*/},\nset accessor_prop(value){/*这里是函数体*/}\n};\n\n将存取器属性的getter和setter方法看成是属性的特性，也可以把数据属性的值同样看做属性的特性，可以认为一个属性包含一个名字和4个特性，数据属性的4个特性分别是它的值（value）、可写性（writable）、可枚举性（enumerable）和可配置性（configurable），存取器属性不具有值（value）特性和可写性，它们的可写性是由setter方法存在与否决定的，因此存取器属性的4个特性是读取（get）、写入（set）、可枚举性和可配置性\n\n为了实现属性特性的查询和设置操作，定义了名为“属性描述符”的都对象，这个对象代表那4个属性，数据属性的描述符对象的属性有value、writable、enumerable和configurable,存取器属性的描述符对象则用get属性和set属性代替value和writable，其中writable、enumerable和configurable都是布尔值，get和set属性是函数值\n\n通过调用Object.getOwnPropertyDescriptor(要查询的对象,查询的对象中的属性)可以获得某个对象特定属性的属性描述符;\n//返回{value:1,writable:true,enumerable:true,configurable:true}\nObject.getOwnPropertyDescriptor({x:1},\"x\");\n\nObject.getOwnPropertyDescriptor()只能得到自有属性的描述符，想要获得继承属性的特性，需要遍历原型链Object.getPrototypeOf()\n\n#### 任何对Object.defineProperty()或Object.defineProperties()违反规则的使用都会抛出类型错误异常：\n1.如果对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性\n2.如果存取器属性是不可配置的，则不能修改其getter和setter方法，也不能将它转换为数据属性\n3.如果数据属性是不可配置的，则不能将它转换为存取器属性\n4.如果数据属性是不可配置的，则不能将它的可写性从false修改为true，但可以从true修改为false\n5.如果数据属性是不可配置且不可写的，则不能修改它的值。然而可配置但不可写属性的值是可以修改的（实际上是先将它标记为可写的，然后修改它的值，最后转换为不可写的）\n\n### 对象的三个属性\n#### 原型属性\n原型属性用来继承属性\n\n通过对象直接量创建的对象使用Object.prototype作为它们的原型\n\n通过new创建的对象使用构造函数的prototype属性作为它们的原型\n\n通过Object.create()创建的对象使用第一个参数作为它们的原型\n\n将对象作为参数传入Object.getPrototypeOf()可以查询它的原型\n\n通过对象直接量或Object.create()创建的对象包含一个名为constructor的属性，这\n个属性指代Object()构造函数，constructor.prototype才是对象直接量的真正的原型，但对于通过Object.create()创建的对象则往往不是这样\n\n要想检测一个对象是否是另一个对象的原型（或处于原型链中），请使用isPrototypeOf()方法。例如，可以通过p.isPrototypeOf(o)来检测p是否是o的原型：\nlet p={x:1};//定义一个原型对象\nlet o=Object.create(p);//使用这个原型创建一个对象\np.isPrototypeOf(o)//=＞true:o继承自p\nObject.prototype.isPrototypeOf(o)//=＞true:p继承自Object.prototype\n\n### 类属性\n要想获得对象的类，可以调用对象的toString()方法，然后提取已返回字符串的第8个到倒数第二个位置之间的字符\n\n### 序列化对象\n对象序列化将对象的状态转换为字符串，也可将字符串还原为对象\n\nJSON.stringify()和JSON.parse()用来序列化和还原JavaScript对象\n\njson全称是JavaScript Object Notation ---JavaScript对象表示法\n\n### 对象方法\ntoString()没有参数，返回一个调用这个方法的对象值的字符串，将对象转换为字符串的时候，JavaScript都会调用该方法，比如当使用\"+\"连接一个字符串和一个对象都会调用对象的toString()\n\ntoLocaleString()这个方法返回一个表示这个对象的本地化字符串\n\nObject中默认的toLocaleString()方法并不做任何本地化自身的操作，它仅调用toString()\n方法并返回对应值。Date和Number类对toLocaleString()方法做了定制，可以用它对数字、日期和时间做本地化的转换\n\ntoJSON()对于需要执行序列化的对象来说，JSON.stringify()方法会调用toJSON()方法。如果在待序列化的对象中存在这个方法，则调用它，返回值即是序列化的结果，而不是原始的对象。\n\n## 数组\n数组是值的有序集合，数组无类型，JavaScript数组的索引是基于零的32位数值：第一个元素的索引为0，最大可能的索引为4294967294（2^32-2），数组最大能容纳4294967295个元素\n\n稀疏数组就是包含从0开始的不连续索引的数组,，数组的length属性值代表数组中元素的个数。如果数组是稀疏的，length属性值大于元素的个数。可用Array()构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。\n\n足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，在这样的数组中查找元素的时间与常规对象属性的查找时间一样长\n\n当在数组直接量中省略值时不会创建稀疏数组，省略的元素在数组中是存在的，其值为undefined，这和数组元素根本不存在是有一些微妙的区别的\n\n使用push()方法在数组末尾增加一个或多个元素\nunshift()在数组的首部插入一个元素，并将其他元素依次移到更高的索引处\n\n对一个数组元素使用delete不会修改数组的length属性，也不会将元素从高索引处移下来填充已删除属性留下的空白。如果从数组中删除一个元素，它就变成稀疏数组\n\n数组有pop()方法（它和push()一起使用），后者一次使减少长度1并返回被删除元素的值。还有一个shift()方法（它和unshift()一起使用），从数组头部删除一个元素。和delete不同的是shift()方法将所有元素下移到比当前索引低1的地方\n\nArray.join()方法将数组中所有元素都转化为字符串并连接在一起，返回最后生成的字符串，默认使用\",\"来分割数组中的元素\n\nArray.reverse()方法将数组中的元素颠倒顺序，返回逆序的数组，它不通过重新排列的元素创建新的数组，而是在原先的数组中重新排列它们\n\nArray.sort()方法将数组中的元素排序并返回排序后的数组，不带参数调用sort时，数组元素以字母表顺序排序，如果包含undefined，被排在数组的尾部\n\nArray.concat()方法创建并返回一个新数组，它的元素包括调用concat()的原始数组的元素和concat()的每个参数，对迭代的数组无法递归\n\nArray.slice()方法返回指定数组的一个片段或子数组，两个参数分别指定了片段的开始和结束的位置，返回的数组包含第一个参数指定的位置和所有到但不含第二个参数指定的位置之间的所有数组元素，不修改原数组，返回新数组\n\nArray.splice()方法是在数组中插入或删除元素的通用方法。不同于slice()和concat()，splice()会修改调用的数组，splice()能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作，在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其他部分仍然保持连续的\n\npush()和pop()将数组当作栈，push()在数组尾部添加一个或多个元素，并返回新数组的长度，pop()相反，删除最后一个元素，减小数组长度并返回它删除的值，都修改并替换原始数组而非生成一个新数组\n\nunshift()和shift(),在数组的头部插入和删除，unshift()在头部添加并将已存在的元素移动到更高的索引，返回数组新长度，shift()删除数组第一个元素并将其返回，然后把剩下的元素下移一个\n\ntoString()和toLocalString()转换为字符串，以，分隔，同join()效果相同\n\n### 数组的方法\nforEach()从头到尾遍历数组，为每个元素调用指定的函数，传递的函数作为第一个参数，函数体中的三个参数调用，数组元素、元素的索引和数组本身\nforEach()无法在所有元素都传递给调用的函数之前终止遍历，也就是说，没有像for循环中使用的相应的break语句。\n如果要提前终止，必须把forEach()方法放在一个try块中，并能抛出一个异常，如果forEach()调用的函数抛出foreach.break异常，循环会提前终止：\nfunction foreach(a,f,t){\ntry{a.forEach(f,t);}\ncatch(e){\nif(e===foreach.break)return;\nelse throw e;\n}} foreach.break=new Error(\"StopIteration\");\n\nmap()将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值,map()返回的是新数组：它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组：它具有相同的长度，相同的缺失元素\n**传递给map()的函数应该有返回值**\n\nfilter()调用判定函数就像调用forEach()和map()一样。如果返回值为true或能转化为true的值，那么传递给判定函数的元素就是这个子集的成员，它将被添加到一个作为返回值的数组中\n**filter()会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的**\n压缩空缺并删除undefined和null元素，可以这样使用filter()：\na=a.filter(function(x){return x!==undefined＆＆x!=null;});\n\nevery()和some()方法，它们对数组元素应用指定的函数进行判定，返回true或false\nevery()方法就像数学中的“针对所有”的量词：当且仅当针对数组中的所有元素调用判定函数都返回true，它才返回true\na=[1,2,3,4,5];\na.every(function(x){return x＜10;})//=＞true:所有的值＜10\na.every(function(x){return x%2===0;})//=＞false:不是所有的值都是偶数\n\nsome()方法就像数学中的“存在”的量词：当数组中至少有一个元素调用判定函数返回true，它就返回true；并且当且仅当数值中的所有元素调用判定函数都返回false，它才返回false：\na=[1,2,3,4,5];\na.some(function(x){return x%2===0;})//=＞true：a含有偶数值\na.some(isNaN)//=＞false：a不包含非数值元素\n\n**一旦every()和some()确认该返回什么值它们就会停止遍历数组元素。some()在判定函数第一次返回true后就返回true，但如果判定函数一直返回false，它将会遍历整个数组。every()恰好相反：它在判定函数第一次返回false后就返回false，但如果判定函数一直返回true，它将会遍历整个数组。注意，根据数学上的惯例，在空数组上调用时，every()返回true，some()返回false**\n\nreduce()和reduceRight()方法使用指定的函数将数组元素进行组合，生成单个值,可以被称为“注入”和“折叠”：\nreduce()需要两个参数，第一个是化简函数，将两值组合化简为一个值并返回化简的值，第二个参数是一个传递给函数的初始值\n\nindexOf()和lastIndexOf()\nindexOf()和lastIndexOf()搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引或者如果没有找到就返回-1，indexOf()从头至尾搜索，而lastIndexOf()反向搜索\n\n//在数组中查找所有出现的x，并返回一个包含匹配索引的数组\nfunction findall(a,x){\nvar results=[],//将会返回的数组\nlen=a.length,//待搜索数组的长度\npos=0;//开始搜索的位置\nwhile(pos＜len){//循环搜索多个元素...\npos=a.indexOf(x,pos);//搜索\nif(pos===-1)break;//未找到，就完成搜索\nresults.push(pos);//否则，在数组中存储索引\npos=pos+1;//并从下一个位置开始搜索\n} return results;//返回包含索引的数组\n}\n\n## 函数\n嵌套函数的变量作用域规则是它们可以访问嵌套它们的函数的参数和变量，内部函数可以读写外部函数的参数\n\n函数声明语句可以出现在全局代码里，或者嵌套在其他函数中，但它们不能出现在循环、条件判断或者try/cache/finally以及with语句中，函数定义表达式可以出现在javascript代码的任何地方\n\n方法调用和函数调用的区别在于调用上下文，方法的的调用上下文是当前对象，函数的调用上下文在非严格模式下是全局对象，严格模式下是undefined\n\n大多数方法调用使用点符号来访问属性，使用方括号（的属性访问表达式）也可以进行属性访问操作\n\n任何函数被当作方法调用实际都会传入一个隐式的实参，这个实参就是这个方法调用的对象\n\n当方法的返回值是一个对象，这个对象还可以再调用它的方法。这种方法调用序列中（通常称为“链”或者“级联”）每次的调用结果都是另外一个表达式的组成部分\n\n和变量不同，关键字this没有作用域的限制，嵌套的函数不会从调用它的函数中继承this。如果嵌套函数作为方法调用，其this的值指向调用它的对象。如果嵌套函数作为函数调用，其this值不是全局对象（非严格模式下）就是undefined（严格模式下）。很多人误以为调用嵌套函数时this会指向调用外层函数的上下文。如果你想访问这个外部函数的this值，需要将this的值保存在一个变量里，这个变量和内部函数都同在一个作用域内。通常使用变量self来保存this\n\n### 构造函数\n构造函数调用创建一个新的空对象，这个对象继承自构造函数的prototype属性\n构造函数试图初始化这个新创建的对象，并将这个对象用做其调用上下文，因此构造函数可以使用this关键字来引用这个新创建的对象\n\n间接调用，函数也是对象，函数对象也可以包含方法，其中两个方法call()和apply()可以间接调用函数，两个方法都允许显式指定调用所需的this值，也就是说，任何函数可以作为任何对象的方法来调用，哪怕这个函数不是那个对象的方法\n\n## 函数的实参和形参：\n1.可选形参：\n当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值\nif(a===undefined)a=[]等同于 a = a||[]\n当使用可选实参来实现函数时，需将可选实参放在实参列表的最后，调用函数是没办法省略第一个参数而后传入第二个实参的，必须将undefined作为第一个实参显示传入\n\n可变长的实参列表：实参对象\n但调用函数时传入的实参个数超过函数定义时的形参个数，没办法直接获得未命名值的引用\n在函数体内，标识符arguments是指向实参对象的引用，实参对象是一个类数组对象，这样可以通过数字下标访问传入函数的实参值，而不用非要通过名字来得到实参\n\n实参对象让函数可以操作任意数量的实参，函数可以接受任意个数的实参这种函数称为“不定实参函数”，该函数的实参个数不能为零，arguments不是真正的数组，它是一个实参对象，每个实参对象都包含以数字为索引的一组元素以及length属性。\n\ncallee和caller\n实参对象还定义了callee和caller属性，对这两个属性读写操作都会产生一个类型错误，在非严格模式下，callee属性指代当前正在执行的函数，caller是非标准的，它指代调用当前正在执行的函数的函数，caller属性可以访问调用栈\n\n在匿名函数中通过调用callee来递归调用本身\nvar factorial = function(x){\n    if(x<=1)return 1;\n    return x*arguments.callee(x-1);\n}\n\n将对象属性用做实参：通过传入对象的方式可以不必注意参数的顺序\n\n作为值的函数：\n函数不仅是一种语法，也是值，可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另一个函数\n\n自定义函数属性\nJavaScript中的函数并不是原始值，而是一种特殊的对象，函数可以拥有属性\n\nJavaScript中函数作用域的概念：\n函数中声明的变量在函数体内可见，在函数外部不可见，不在函数内声明的变量是全局变量\n（function(){\n//模块代码\n}())\n\n立即调用，function前边的左括号是必需的，如果没有，js解释器会试图将关键字function解析为函数声明语句，使用圆括号js解释器才会正确将其解析为函数定义表达式，命名空间技术\n\n### 闭包\n函数的执行依赖于变量作用域，这个作用域是函数定义时决定的，而不是函数调用时决定的\n函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学中称为闭包\n\nvar scope = \"global scope\";//全局变量\nfunction checkscope(){\n    var scope = \"local scope\";//局部变量\n    function f(){\n        return scope;  //在作用域中返回这个值\n    }\n    return f();\n}\ncheckscope() //local scope\n\nvar scope = \"global scope\";//全局变量\nfunction checkscope(){\n    var scope = \"local scope\";//局部变量\n    function f(){\n        return scope;  //在作用域中返回这个值\n    }\n    return f;\n}\ncheckscope()() //local scope\n\nJavaScript函数的执行用到了作用域链，这个作用域链时函数定义的时候创建的，嵌套的f()定义在作用域链里，其中的scope一直是局部变量，不管在任何时候执行，这种绑定在f()依然有效，\n\n闭包可以捕捉到局部变量（和参数），并一直保存下来，看起来像这些变量绑定到了在其中定义它们的外部函数\n\n"},{"title":"article title","url":"/2019/10/24/article-title/"},{"title":"Hello World","url":"/2019/10/24/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]